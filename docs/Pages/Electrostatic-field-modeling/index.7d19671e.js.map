{"mappings":"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","sources":["<anon>","src/Pages/Electrostatic-field-modeling/index.ts","src/Library/Math/Vector.ts","src/Pages/Electrostatic-field-modeling/calculateIntensityVectorArray.ts","src/Library/Math/Point.ts","src/Library/Math/PointOperations/calculateDistanceBetweenPoints.ts","src/Library/Math/VectorOperations/addVectors.ts","src/Library/Physics/calculateElectrostaticFieldIntensityVector.ts","src/Library/Math/VectorOperations/calculateVectorLength.ts","src/Library/Math/VectorOperations/multiplyVectorByNumber.ts","src/Library/Math/VectorOperations/normalizeVector.ts","src/Library/Math/VectorOperations/subtractVectors.ts","src/Library/Physics/calculateElectrostaticFieldIntensity.ts","src/Library/Physics/Constants.ts","src/Pages/Electrostatic-field-modeling/Consts.ts","src/Pages/Electrostatic-field-modeling/drawElectricChargeArray.ts","src/Pages/Electrostatic-field-modeling/drawCircle.ts","src/Library/Draw/transformToScreen.ts","src/Pages/Electrostatic-field-modeling/drawIntensityVectorArray.ts","src/Library/Draw/drawArrow.ts","src/Library/Draw/createArrowVertexes.ts","src/Library/Math/MatrixOperations/createRotationMatrix.ts","src/Library/Math/MatrixOperations/multiplyMatrixByVectorArray.ts","src/Library/Math/MatrixOperations/multiplyMatrixByVector.ts","src/Library/Math/VectorOperations/calculateVectorAngleByAxisX.ts","src/Library/Draw/createAxisXArrowVertexes.ts","src/Library/Draw/drawArrowOnCanvasContext2D.ts","src/Pages/Electrostatic-field-modeling/drawGridPoint.ts","src/Pages/Electrostatic-field-modeling/map.ts"],"sourcesContent":["class $bfe3c5b1f99c60ca$export$9b781de7bf37bf48 {\n    constructor(x, y){\n        this._x = x;\n        this._y = y;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n}\n\n\nclass $0e38986d1e12c35a$export$baf26146a414f24a {\n    constructor(x, y){\n        this._x = x;\n        this._y = y;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n}\n\n\nfunction $5f7171fd448aba12$export$926841721d7d6cbd(point1, point2) {\n    return Math.sqrt((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y));\n}\n\n\n\n\nfunction $a0ff5dc7feef40ff$export$75064e1c6824e15c(vector1, vector2) {\n    return new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(vector1.x + vector2.x, vector1.y + vector2.y);\n}\n\n\nfunction $ff8e3298100e11ba$export$1688a8338e895043(vector) {\n    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n}\n\n\n\nfunction $8e81cc6caae514b7$export$3748d6ca43eb5eeb(vector, number) {\n    return new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(vector.x * number, vector.y * number);\n}\n\n\n\n\nfunction $9c190cd7d83c0db4$export$4d973b3eababff1d(vector) {\n    const vectorLength = (0, $ff8e3298100e11ba$export$1688a8338e895043)(vector);\n    return new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(vector.x / vectorLength, vector.y / vectorLength);\n}\n\n\n\nfunction $c5d5d6167b05d2e0$export$8fa91d40d0bb1393(vector1, vector2) {\n    return new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(vector1.x - vector2.x, vector1.y - vector2.y);\n}\n\n\n/**\r\n * Коеффициент для вычисления напряженности электростатического поля в точке около заряда.\r\n * Еденица измерения: Н * М^2 / Кл^2\r\n * @type {number}\r\n */ const $6939b8277c814580$export$8610d4f99b77e079 = 9e9;\n\n\nfunction $39f43304e3347fea$export$2752529268d59cb9(distance, electricCharge) {\n    return (0, $6939b8277c814580$export$8610d4f99b77e079) * electricCharge / (distance * distance);\n}\n\n\nfunction $310d99185d328645$export$2cbb74143e92e233(electricCharge, electricChargePosition, testPointPosition) {\n    const distance = (0, $ff8e3298100e11ba$export$1688a8338e895043)((0, $c5d5d6167b05d2e0$export$8fa91d40d0bb1393)(testPointPosition, electricChargePosition));\n    const normalisedIntensityVector = (0, $9c190cd7d83c0db4$export$4d973b3eababff1d)((0, $c5d5d6167b05d2e0$export$8fa91d40d0bb1393)(testPointPosition, electricChargePosition));\n    return (0, $8e81cc6caae514b7$export$3748d6ca43eb5eeb)(normalisedIntensityVector, (0, $39f43304e3347fea$export$2752529268d59cb9)(distance, electricCharge));\n}\n\n\nconst $378929a1c2d882fe$export$d5147ecc49b397a1 = 0.25;\nconst $378929a1c2d882fe$export$6c421550c66a327d = 1e-6;\nconst $378929a1c2d882fe$export$adfa613fb614d750 = 10;\nconst $378929a1c2d882fe$export$ebd1b5f3b0815eec = 15;\nconst $378929a1c2d882fe$export$d51dff18a29e6fdb = 10;\nconst $378929a1c2d882fe$export$f3109f93edf6a555 = 10;\n\n\nfunction $a924bb3ca0a1f0a6$export$60e509577e93a305(electricChargeArray) {\n    const example = document.querySelector(\"#example canvas\");\n    if (!(example instanceof HTMLCanvasElement)) throw new Error(\"Ожидался HTMLCanvasElement\");\n    const ctx = example.getContext(\"2d\");\n    ctx.canvas.width = window.innerWidth;\n    ctx.canvas.height = window.innerHeight;\n    const ratio = example.width / example.height;\n    const cameraWidth = (0, $378929a1c2d882fe$export$adfa613fb614d750) * ratio;\n    // Конвертация координат в метрах в координаты в пикселах экрана.\n    const convertToScreen = example.height / (0, $378929a1c2d882fe$export$adfa613fb614d750);\n    // Вычисляем массив точек, в которых надо рассчитать напряженность поля.\n    const testPoints = [];\n    for(let y = 0; y < (0, $378929a1c2d882fe$export$adfa613fb614d750); y += (0, $378929a1c2d882fe$export$d5147ecc49b397a1))for(let x = 0; x < cameraWidth; x += (0, $378929a1c2d882fe$export$d5147ecc49b397a1)){\n        const point = new (0, $0e38986d1e12c35a$export$baf26146a414f24a)(x, y);\n        const dist = (0, $5f7171fd448aba12$export$926841721d7d6cbd);\n        // Если точка не совпала ни с одним из зарядом, то помещаем ее в массив gridPoints.\n        if (electricChargeArray.reduce((result, charge)=>result && dist(charge.positionInMeters, point) > (0, $378929a1c2d882fe$export$6c421550c66a327d), true)) testPoints.push(point);\n    }\n    /**\r\n\t * Массив векторной напряжёности в каждой точке сетки.\r\n\t * @type {{intensityVector: Vector, position: Vector}[]}\r\n\t */ const intensityVectorArray = [];\n    // Вычисление векторной напряжёности в каждой точке сетки.\n    for (const { x: x, y: y } of testPoints){\n        let intensityVector = new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(0, 0);\n        for(let i = 0; i < electricChargeArray.length; i++)intensityVector = (0, $a0ff5dc7feef40ff$export$75064e1c6824e15c)(intensityVector, (0, $310d99185d328645$export$2cbb74143e92e233)(electricChargeArray[i].value, electricChargeArray[i].positionInMeters, new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(x, y)));\n        intensityVectorArray.push({\n            intensityVector: intensityVector,\n            position: new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(x, y)\n        });\n    }\n    return intensityVectorArray;\n}\n\n\n\n\nfunction $13e4ba37a9f785f5$export$1c1772b000b7cc30(point, canvas) {\n    return new (0, $0e38986d1e12c35a$export$baf26146a414f24a)(point.x, -point.y + canvas.height);\n}\n\n\n\nfunction $f2131ef713eafc37$export$8daab6f91f7ff730(x, y, radius, scale, canvasElement) {\n    const ctx = canvasElement.getContext(\"2d\");\n    const point = (0, $13e4ba37a9f785f5$export$1c1772b000b7cc30)(new (0, $0e38986d1e12c35a$export$baf26146a414f24a)(x * scale, y * scale), canvasElement);\n    ctx.beginPath();\n    ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.stroke();\n}\n\n\n\nfunction $4da7bff587c864f7$export$a1f5d08aff123b7d(electricChargeArray, canvasElement, ctx) {\n    const ratio = canvasElement.width / canvasElement.height;\n    const cameraWidth = (0, $378929a1c2d882fe$export$adfa613fb614d750) * ratio;\n    // Конвертация координат в метрах в координаты в пикселах экрана.\n    const convertToScreen = canvasElement.height / (0, $378929a1c2d882fe$export$adfa613fb614d750);\n    /**\r\n\t * Рисование всех зарядов\r\n\t */ for(let i = 0; i < electricChargeArray.length; i++)if (electricChargeArray[i].value > 0) {\n        ctx.fillStyle = \"red\";\n        ctx.strokeStyle = \"darkred\";\n        (0, $f2131ef713eafc37$export$8daab6f91f7ff730)(electricChargeArray[i].positionInMeters.x, electricChargeArray[i].positionInMeters.y, (0, $378929a1c2d882fe$export$d51dff18a29e6fdb), convertToScreen, canvasElement);\n    } else {\n        ctx.fillStyle = \"blue\";\n        ctx.strokeStyle = \"darkblue\";\n        (0, $f2131ef713eafc37$export$8daab6f91f7ff730)(electricChargeArray[i].positionInMeters.x, electricChargeArray[i].positionInMeters.y, (0, $378929a1c2d882fe$export$d51dff18a29e6fdb), convertToScreen, canvasElement);\n    }\n}\n\n\nfunction $956e32580d3a8e04$export$7c79514a80dc15a2(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    return [\n        [\n            cos,\n            -sin\n        ],\n        [\n            sin,\n            cos\n        ]\n    ];\n}\n\n\n\nfunction $f9f713890e72bdf5$export$5a8a2ab9d445df8(matrix, vector) {\n    return new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(matrix[0][0] * vector.x + matrix[0][1] * vector.y, matrix[1][0] * vector.x + matrix[1][1] * vector.y);\n}\n\n\nfunction $e00cd10a0049d85f$export$8845a6db2cca6dbf(matrix, vectorArray) {\n    const result = [];\n    for (const vector of vectorArray)result.push((0, $f9f713890e72bdf5$export$5a8a2ab9d445df8)(matrix, vector));\n    return result;\n}\n\n\n\n/**\r\n * Угол между вектором и осью Х.\r\n * Угол отсчитывается от оси Х против часовой стрелки до вектора.\r\n * Может быть отрицательным, то есть может принимать значения от -Math.PI до Math.PI.\r\n * @param {Vector} vector\r\n * @returns\r\n */ function $bc65a6eda55c7ee9$export$5423bb6e0c6a8a4(vector) {\n    return Math.atan2(vector.y, vector.x);\n}\n\n\nfunction $7eecad62c9d440ec$export$854a02f31c923629(point1, point2, normalizedArrowVertexes) {\n    let resultArrowVertexes = [];\n    // Вращаем стрелку\n    const arrowAngle = (0, $bc65a6eda55c7ee9$export$5423bb6e0c6a8a4)(new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(point2.x - point1.x, point2.y - point1.y));\n    const rotationMatrix = (0, $956e32580d3a8e04$export$7c79514a80dc15a2)(arrowAngle);\n    resultArrowVertexes = (0, $e00cd10a0049d85f$export$8845a6db2cca6dbf)(rotationMatrix, normalizedArrowVertexes);\n    // Перемещаем стрелку\n    const arrowPosition = new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(point1.x, point1.y);\n    let resultArrowVertexes2 = [];\n    for (const normalizedVertex of resultArrowVertexes)resultArrowVertexes2.push(new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(normalizedVertex.x + arrowPosition.x, normalizedVertex.y + arrowPosition.y));\n    return resultArrowVertexes2;\n}\n\n\n\n\n/**\r\n * Высота головы стрелки по умолчанию.\r\n */ const $571545cba5ccd7d0$var$headArrowDefaultHeight = 10;\n/**\r\n * Ширина головы стрелки по умолчанию.\r\n */ const $571545cba5ccd7d0$var$headArrowDefaultWidth = 10;\nfunction $571545cba5ccd7d0$export$84da017e1e5354fd(point1, point2, options) {\n    const { headArrowWidth: headArrowWidth = $571545cba5ccd7d0$var$headArrowDefaultWidth, headArrowHeight: headArrowHeight = $571545cba5ccd7d0$var$headArrowDefaultHeight } = options;\n    const arrowLength = (0, $5f7171fd448aba12$export$926841721d7d6cbd)(point1, point2);\n    const result = [\n        new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(0, 0)\n    ];\n    result.push(new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(arrowLength, 0));\n    result.push(new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(arrowLength - headArrowHeight, headArrowWidth / 2));\n    result.push(new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(arrowLength - headArrowHeight, -headArrowWidth / 2));\n    return result;\n}\n\n\n/**\r\n * Высота головы стрелки по умолчанию.\r\n */ const $dfbad06fb004b8e2$var$headArrowDefaultHeight = 10;\n/**\r\n * Ширина головы стрелки по умолчанию.\r\n */ const $dfbad06fb004b8e2$var$headArrowDefaultWidth = 10;\nfunction $dfbad06fb004b8e2$export$f6d70d79295e1392(point1, point2, options) {\n    const { draw: draw } = options;\n    // Создаем стрелку на оси Х.\n    const normalizedArrowVertexes = (0, $571545cba5ccd7d0$export$84da017e1e5354fd)(point1, point2, options);\n    // Создаем стрелку уже на своем месте.\n    const arrowVertexes = (0, $7eecad62c9d440ec$export$854a02f31c923629)(point1, point2, normalizedArrowVertexes);\n    // Рисуем стрелку.\n    draw(arrowVertexes);\n}\n\n\nfunction $5ab70a5774eb6ee5$export$466d0ec538703cec(arrowVertexes, ctx) {\n    ctx.moveTo(arrowVertexes[0].x, arrowVertexes[0].y);\n    ctx.lineTo(arrowVertexes[1].x, arrowVertexes[1].y);\n    ctx.lineTo(arrowVertexes[2].x, arrowVertexes[2].y);\n    ctx.moveTo(arrowVertexes[1].x, arrowVertexes[1].y);\n    ctx.lineTo(arrowVertexes[3].x, arrowVertexes[3].y);\n    ctx.stroke();\n}\n\n\n\n\n\n\n\n\n\n\nfunction $a336bf582a415e35$export$3e534c17018ef964(x, y, scale, canvasElement) {\n    let ctx = canvasElement.getContext(\"2d\");\n    const point = (0, $13e4ba37a9f785f5$export$1c1772b000b7cc30)(new (0, $0e38986d1e12c35a$export$baf26146a414f24a)(x * scale, y * scale), canvasElement);\n    ctx.fillRect(point.x, point.y, 1, 1);\n    ctx.fillRect(point.x + 1, point.y, 1, 1);\n    ctx.fillRect(point.x - 1, point.y, 1, 1);\n    ctx.fillRect(point.x, point.y + 1, 1, 1);\n    ctx.fillRect(point.x, point.y - 1, 1, 1);\n}\n\n\n\nfunction $f4e029a04735410f$export$871de8747c9eaa88(x, in_min, in_max, out_min, out_max) {\n    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\n\nfunction $9d206efe08958c32$export$18702c308d731ad3(intensityVectorArray, canvasElement, ctx) {\n    const ratio = canvasElement.width / canvasElement.height;\n    const cameraWidth = (0, $378929a1c2d882fe$export$adfa613fb614d750) * ratio;\n    // Конвертация координат в метрах в координаты в пикселах экрана.\n    const convertToScreen = canvasElement.height / (0, $378929a1c2d882fe$export$adfa613fb614d750);\n    // Отрисовка сетки с тестовыми точками.\n    for(let y = 0; y < (0, $378929a1c2d882fe$export$adfa613fb614d750); y += (0, $378929a1c2d882fe$export$d5147ecc49b397a1))for(let x = 0; x < cameraWidth; x += (0, $378929a1c2d882fe$export$d5147ecc49b397a1)){\n        ctx.beginPath();\n        ctx.fillStyle = `hsl(0, 0%, 85%)`;\n        (0, $a336bf582a415e35$export$3e534c17018ef964)(x, y, convertToScreen, canvasElement);\n    }\n    /**\r\n\t *\t Рисование стрелок на основе данных из intensityVectorArray\r\n\t */ const minValueIntensity = (0, $39f43304e3347fea$export$2752529268d59cb9)((0, $378929a1c2d882fe$export$f3109f93edf6a555), 1);\n    const maxValueIntensity = (0, $39f43304e3347fea$export$2752529268d59cb9)(1, 1);\n    for(let i = 0; i < intensityVectorArray.length; i++){\n        const intensity = (0, $ff8e3298100e11ba$export$1688a8338e895043)(intensityVectorArray[i].intensityVector);\n        if (intensity > (0, $378929a1c2d882fe$export$6c421550c66a327d)) {\n            ctx.beginPath();\n            const direction = (0, $8e81cc6caae514b7$export$3748d6ca43eb5eeb)((0, $9c190cd7d83c0db4$export$4d973b3eababff1d)(intensityVectorArray[i].intensityVector), (0, $378929a1c2d882fe$export$ebd1b5f3b0815eec));\n            let color = 0;\n            // const middleValueIntensity = (maxValueIntensity + minValueIntensity) / 2\n            // if (intensity < middleValueIntensity) {\n            // \tcolor = Math.round(map(intensity, minValueIntensity, middleValueIntensity, 255, 0))\n            // }\n            color = Math.round((0, $f4e029a04735410f$export$871de8747c9eaa88)(intensity, minValueIntensity, maxValueIntensity, 255, 0));\n            ctx.strokeStyle = `rgb(${color}, ${color}, ${color})`;\n            (0, $dfbad06fb004b8e2$export$f6d70d79295e1392)((0, $13e4ba37a9f785f5$export$1c1772b000b7cc30)(new (0, $0e38986d1e12c35a$export$baf26146a414f24a)(intensityVectorArray[i].position.x * convertToScreen, intensityVectorArray[i].position.y * convertToScreen), canvasElement), (0, $13e4ba37a9f785f5$export$1c1772b000b7cc30)(new (0, $0e38986d1e12c35a$export$baf26146a414f24a)(intensityVectorArray[i].position.x * convertToScreen + direction.x, intensityVectorArray[i].position.y * convertToScreen + direction.y), canvasElement), {\n                headArrowWidth: 10,\n                headArrowHeight: 10,\n                draw: (arrowVertexes)=>(0, $5ab70a5774eb6ee5$export$466d0ec538703cec)(arrowVertexes, ctx)\n            });\n        }\n    }\n}\n\n\n// Входные параметры.\n/**\r\n * Массив зарядов.\r\n * @type {[{positionInMeters: Vector, value: number},{positionInMeters: Vector, value: number}]}\r\n */ const $00919d6f63f91579$var$electricChargeArray = [\n    {\n        value: 1,\n        positionInMeters: new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(5, 5)\n    },\n    {\n        value: 1,\n        positionInMeters: new (0, $bfe3c5b1f99c60ca$export$9b781de7bf37bf48)(8, 5)\n    }\n];\n/**\r\n * Основные вычисления.\r\n  */ const $00919d6f63f91579$var$intensityVectorArray = (0, $a924bb3ca0a1f0a6$export$60e509577e93a305)($00919d6f63f91579$var$electricChargeArray);\n/**\r\n * Отрисовка результов на экране.\r\n * @type {Element}\r\n */ const $00919d6f63f91579$var$canvasElement = document.querySelector(\"#example canvas\");\nif (!($00919d6f63f91579$var$canvasElement instanceof HTMLCanvasElement)) throw new Error(\"Ожидался HTMLCanvasElement\");\nconst $00919d6f63f91579$var$ctx = $00919d6f63f91579$var$canvasElement.getContext(\"2d\");\n(0, $9d206efe08958c32$export$18702c308d731ad3)($00919d6f63f91579$var$intensityVectorArray, $00919d6f63f91579$var$canvasElement, $00919d6f63f91579$var$ctx);\n(0, $4da7bff587c864f7$export$a1f5d08aff123b7d)($00919d6f63f91579$var$electricChargeArray, $00919d6f63f91579$var$canvasElement, $00919d6f63f91579$var$ctx);\n/**\r\n * Элемент текста который показывает масштаб сетки.\r\n * @type {HTMLElement}\r\n */ const $00919d6f63f91579$var$scaleTextElement = document.getElementById(\"scale\");\n$00919d6f63f91579$var$scaleTextElement.innerText = \"Масштаб \" + (0, $378929a1c2d882fe$export$d5147ecc49b397a1) + \" метр(ов) между точками\";\n\n\n//# sourceMappingURL=index.7d19671e.js.map\n","import {Vector} from '../../Library/Math/Vector'\r\nimport {calculateIntensityVectorArray} from './calculateIntensityVectorArray'\r\nimport {gridStepInMeters} from './Consts'\r\nimport {drawElectricChargeArray} from './drawElectricChargeArray'\r\nimport {drawIntensityVectorArray} from './drawIntensityVectorArray'\r\n\r\n// Входные параметры.\r\n/**\r\n * Массив зарядов.\r\n * @type {[{positionInMeters: Vector, value: number},{positionInMeters: Vector, value: number}]}\r\n */\r\nconst electricChargeArray = [\r\n\t{\r\n\t\tvalue: 1,\r\n\t\tpositionInMeters: new Vector(5, 5)\r\n\t},\r\n\t{\r\n\t\tvalue: 1,\r\n\t\tpositionInMeters: new Vector(8, 5)\r\n\t}\r\n]\r\n\r\n/**\r\n * Основные вычисления.\r\n  */\r\nconst intensityVectorArray = calculateIntensityVectorArray(electricChargeArray)\r\n\r\n/**\r\n * Отрисовка результов на экране.\r\n * @type {Element}\r\n */\r\nconst canvasElement = document.querySelector('#example canvas')\r\nif (!(canvasElement instanceof HTMLCanvasElement)) {\r\n\tthrow new Error('Ожидался HTMLCanvasElement')\r\n}\r\nconst ctx = canvasElement.getContext('2d')\r\n\r\ndrawIntensityVectorArray(intensityVectorArray, canvasElement, ctx)\r\ndrawElectricChargeArray(electricChargeArray, canvasElement, ctx)\r\n\r\n/**\r\n * Элемент текста который показывает масштаб сетки.\r\n * @type {HTMLElement}\r\n */\r\nconst scaleTextElement = document.getElementById('scale')\r\nscaleTextElement.innerText = 'Масштаб ' + gridStepInMeters + ' метр(ов) между точками'","export class Vector {\r\n    private _x: number\r\n    private _y: number\r\n    constructor(x, y) {\r\n        this._x = x\r\n        this._y = y\r\n    }\r\n\r\n    get x() {\r\n        return this._x\r\n    }\r\n    get y() {\r\n        return this._y\r\n    }\r\n}","import {Point} from '../../Library/Math/Point'\r\nimport {calculateDistanceBetweenPoints} from '../../Library/Math/PointOperations/calculateDistanceBetweenPoints'\r\nimport {Vector} from '../../Library/Math/Vector'\r\nimport {addVectors} from '../../Library/Math/VectorOperations/addVectors'\r\nimport {\r\n    calculateElectrostaticFieldIntensityVector\r\n} from '../../Library/Physics/calculateElectrostaticFieldIntensityVector'\r\nimport {cameraHeight, epsilon, gridStepInMeters} from './Consts'\r\n\r\nexport function calculateIntensityVectorArray(electricChargeArray) {\r\n\r\n\tconst example = document.querySelector('#example canvas')\r\n\tif (!(example instanceof HTMLCanvasElement)) {\r\n\t\tthrow new Error('Ожидался HTMLCanvasElement')\r\n\t}\r\n\tconst ctx = example.getContext('2d')\r\n\r\n\tctx.canvas.width  = window.innerWidth;\r\n\tctx.canvas.height = window.innerHeight;\r\n\r\n\tconst ratio = example.width / example.height\r\n\tconst cameraWidth = cameraHeight * ratio\r\n\r\n\t// Конвертация координат в метрах в координаты в пикселах экрана.\r\n\tconst convertToScreen = example.height / cameraHeight\r\n\r\n\t// Вычисляем массив точек, в которых надо рассчитать напряженность поля.\r\n\tconst testPoints = []\r\n\tfor (let y = 0; y < cameraHeight; y += gridStepInMeters) {\r\n\t\tfor (let x = 0; x < cameraWidth; x += gridStepInMeters) {\r\n\t\t\tconst point = new Point(x, y)\r\n\t\t\tconst dist = calculateDistanceBetweenPoints\r\n\t\t\t// Если точка не совпала ни с одним из зарядом, то помещаем ее в массив gridPoints.\r\n\t\t\tif (electricChargeArray.reduce((result, charge) => result && dist(charge.positionInMeters, point) > epsilon, true)) {\r\n\t\t\t\ttestPoints.push(point)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Массив векторной напряжёности в каждой точке сетки.\r\n\t * @type {{intensityVector: Vector, position: Vector}[]}\r\n\t */\r\n\tconst intensityVectorArray = []\r\n\t// Вычисление векторной напряжёности в каждой точке сетки.\r\n\tfor (const {x, y} of testPoints) {\r\n\t\tlet intensityVector = new Vector(0, 0)\r\n\r\n\t\tfor (let i = 0; i < electricChargeArray.length; i++) {\r\n\t\t\tintensityVector = addVectors(\r\n\t\t\t\tintensityVector,\r\n\t\t\t\tcalculateElectrostaticFieldIntensityVector(\r\n\t\t\t\t\telectricChargeArray[i].value,\r\n\t\t\t\t\telectricChargeArray[i].positionInMeters,\r\n\t\t\t\t\tnew Vector(x, y)\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t}\r\n\t\tintensityVectorArray.push({intensityVector: intensityVector, position: new Vector(x, y)})\r\n\t}\r\n\treturn intensityVectorArray\r\n}","export class Point {\r\n\tprivate _x: number\r\n\tprivate _y: number\r\n\tconstructor(x, y) {\r\n\t\tthis._x = x\r\n\t\tthis._y = y\r\n\t}\r\n\r\n\tget x() {\r\n\t\treturn this._x\r\n\t}\r\n\r\n\tget y() {\r\n\t\treturn this._y\r\n    }\r\n}","export function calculateDistanceBetweenPoints(point1, point2) {\r\n    return Math.sqrt((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y))\r\n}","import {Vector} from '../Vector'\r\n\r\nexport function addVectors(vector1, vector2) {\r\n    return new Vector(vector1.x + vector2.x, vector1.y + vector2.y)\r\n}","import {calculateVectorLength} from '../Math/VectorOperations/calculateVectorLength'\r\nimport {multiplyVectorByNumber} from '../Math/VectorOperations/multiplyVectorByNumber'\r\nimport {normalizeVector} from '../Math/VectorOperations/normalizeVector'\r\nimport {subtructVectors} from '../Math/VectorOperations/subtractVectors'\r\nimport {calculateElectrostaticFieldIntensity} from './calculateElectrostaticFieldIntensity'\r\n\r\n/**\r\n * Формула вычисления напряженности электростатического поля в точке около заряда в векторной форме.\r\n * Формула потроена на основе закона Кулона и опредиления напряженности.\r\n * @param {number} electricCharge\r\n * @param {import('../Math/Vector')} electricChargePosition\r\n * @param {import('../Math/Vector')} testPointPosition\r\n * @returns {import('../Math/Vector')}\r\n */\r\nexport function calculateElectrostaticFieldIntensityVector(electricCharge, electricChargePosition, testPointPosition) {\r\n\tconst distance = calculateVectorLength(\r\n\t\tsubtructVectors(\r\n\t\t\ttestPointPosition,\r\n\t\t\telectricChargePosition\r\n\t\t)\r\n\t)\r\n\r\n\tconst normalisedIntensityVector = normalizeVector(\r\n\t\tsubtructVectors(\r\n\t\t\ttestPointPosition, electricChargePosition\r\n\t\t)\r\n\t)\r\n\r\n\treturn (\r\n\t\tmultiplyVectorByNumber(\r\n\t\t\tnormalisedIntensityVector,\r\n\t\t\tcalculateElectrostaticFieldIntensity(\r\n\t\t\t\tdistance,\r\n\t\t\t\telectricCharge\r\n\t\t\t)\r\n\t\t)\r\n\t)\r\n}\r\n","export function calculateVectorLength(vector){\r\n\treturn Math.sqrt((vector.x * vector.x) + (vector.y * vector.y))\r\n}","import {Vector} from '../Vector'\r\n\r\nexport function multiplyVectorByNumber(vector, number){\r\n\treturn new Vector(vector.x * number, vector.y * number)\r\n}","import {Vector} from '../Vector'\r\nimport {calculateVectorLength} from './calculateVectorLength'\r\n\r\nexport function normalizeVector(vector){\r\n\tconst vectorLength = calculateVectorLength(vector)\r\n\treturn new Vector(vector.x / vectorLength, vector.y / vectorLength)\r\n}","import {Vector} from '../Vector'\r\n\r\nexport function subtructVectors(vector1, vector2) {\r\n    return new Vector(vector1.x - vector2.x, vector1.y - vector2.y)\r\n}","import {electrostaticFieldIntensityRatio} from './Constants'\r\n\r\n/**\r\n * Формула вычисления напряженности электростатического поля в точке около заряда.\r\n * Формула потроена на основе закона Кулона и опредиления напряженности.\r\n * @param {number} distance Расстояние между тестируемой точкой и точечным зарядом (метр).\r\n * @param {number} electricCharge Значение точечного заряда (Кулон).\r\n * @return {number} напряженность электростатического поля (Кулон).\r\n */\r\nexport function calculateElectrostaticFieldIntensity(distance, electricCharge) {\r\n\treturn electrostaticFieldIntensityRatio * electricCharge / (distance * distance)\r\n}","/**\r\n * Коеффициент для вычисления напряженности электростатического поля в точке около заряда.\r\n * Еденица измерения: Н * М^2 / Кл^2\r\n * @type {number}\r\n */\r\nexport const electrostaticFieldIntensityRatio = 9e9","export const gridStepInMeters = 0.25\r\n\r\nexport const epsilon = 1e-6\r\n\r\nexport const cameraHeight = 10\r\n\r\n// Длина стрелки в пикселях.\r\n// const arrowLengthPx = (gridStepInMeters / 2) * scale\r\nexport const arrowLengthPx = 15\r\n\r\nexport const electricChargeSize = 10\r\n\r\nexport const electrostaticDrawDistance = 10","import {drawCircle} from './drawCircle'\r\nimport {cameraHeight, electricChargeSize} from './Consts'\r\n\r\nexport function drawElectricChargeArray(electricChargeArray, canvasElement, ctx) {\r\n\r\n\tconst ratio = canvasElement.width / canvasElement.height\r\n\tconst cameraWidth = cameraHeight * ratio\r\n\r\n\t// Конвертация координат в метрах в координаты в пикселах экрана.\r\n\tconst convertToScreen = canvasElement.height / cameraHeight\r\n\r\n\t/**\r\n\t * Рисование всех зарядов\r\n\t */\r\n\tfor (let i = 0; i < electricChargeArray.length; i++) {\r\n\t\tif (electricChargeArray[i].value > 0) {\r\n\t\t\tctx.fillStyle = 'red'\r\n\t\t\tctx.strokeStyle = 'darkred'\r\n\r\n\t\t\tdrawCircle(\r\n\t\t\t\telectricChargeArray[i].positionInMeters.x,\r\n\t\t\t\telectricChargeArray[i].positionInMeters.y,\r\n\t\t\t\telectricChargeSize,\r\n\t\t\t\tconvertToScreen,\r\n\t\t\t\tcanvasElement\r\n\t\t\t)\r\n\t\t} else {\r\n\t\t\tctx.fillStyle = 'blue'\r\n\t\t\tctx.strokeStyle = 'darkblue'\r\n\r\n\t\t\tdrawCircle(\r\n\t\t\t\telectricChargeArray[i].positionInMeters.x,\r\n\t\t\t\telectricChargeArray[i].positionInMeters.y,\r\n\t\t\t\telectricChargeSize,\r\n\t\t\t\tconvertToScreen,\r\n\t\t\t\tcanvasElement\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n}","import {transformToScreen} from '../../Library/Draw/transformToScreen'\r\nimport {Point} from '../../Library/Math/Point'\r\n\r\nexport function drawCircle(x, y, radius, scale, canvasElement) {\r\n\tconst ctx = canvasElement.getContext('2d')\r\n\tconst point = transformToScreen(new Point(x * scale, y * scale), canvasElement)\r\n\tctx.beginPath()\r\n\tctx.arc(point.x, point.y, radius, 0, 2 * Math.PI, false)\r\n\tctx.fill()\r\n\tctx.stroke()\r\n}","import {Point} from '../Math/Point'\r\n\r\n/**\r\n * Трансформация точек перед отображением на холсте.\r\n * Переворачиваем изображение по вертикали и смещаем вниз на высоту холста.\r\n * @param {Point} point\r\n * @returns\r\n */\r\nexport function transformToScreen(point, canvas) {\r\n\treturn new Point(point.x, -point.y + canvas.height)\r\n}","import {drawArrow} from '../../Library/Draw/drawArrow'\r\nimport {drawArrowOnCanvasContext2D} from '../../Library/Draw/drawArrowOnCanvasContext2D'\r\nimport {transformToScreen} from '../../Library/Draw/transformToScreen'\r\nimport {Point} from '../../Library/Math/Point'\r\nimport {calculateVectorLength} from '../../Library/Math/VectorOperations/calculateVectorLength'\r\nimport {multiplyVectorByNumber} from '../../Library/Math/VectorOperations/multiplyVectorByNumber'\r\nimport {normalizeVector} from '../../Library/Math/VectorOperations/normalizeVector'\r\nimport {calculateElectrostaticFieldIntensity} from '../../Library/Physics/calculateElectrostaticFieldIntensity'\r\nimport {drawGridPoint} from './drawGridPoint'\r\nimport {arrowLengthPx, cameraHeight, electrostaticDrawDistance, epsilon, gridStepInMeters} from './Consts'\r\nimport {map} from './map'\r\n\r\nexport function drawIntensityVectorArray(intensityVectorArray, canvasElement, ctx) {\r\n\r\n\tconst ratio = canvasElement.width / canvasElement.height\r\n\tconst cameraWidth = cameraHeight * ratio\r\n\r\n\t// Конвертация координат в метрах в координаты в пикселах экрана.\r\n\tconst convertToScreen = canvasElement.height / cameraHeight\r\n\r\n\t// Отрисовка сетки с тестовыми точками.\r\n\tfor (let y = 0; y < cameraHeight; y += gridStepInMeters) {\r\n\t\tfor (let x = 0; x < cameraWidth; x += gridStepInMeters) {\r\n\t\t\tctx.beginPath()\r\n\t\t\tctx.fillStyle = `hsl(0, 0%, 85%)`\r\n\t\t\tdrawGridPoint(x, y, convertToScreen, canvasElement)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\t Рисование стрелок на основе данных из intensityVectorArray\r\n\t */\r\n\tconst minValueIntensity = calculateElectrostaticFieldIntensity(electrostaticDrawDistance, 1)\r\n\tconst maxValueIntensity = calculateElectrostaticFieldIntensity(1, 1)\r\n\r\n\tfor (let i = 0; i < intensityVectorArray.length; i++) {\r\n\t\tconst intensity = calculateVectorLength(intensityVectorArray[i].intensityVector)\r\n\r\n\t\tif (intensity > epsilon) {\r\n\r\n\t\t\tctx.beginPath()\r\n\r\n\t\t\tconst direction = multiplyVectorByNumber(\r\n\t\t\t\tnormalizeVector(intensityVectorArray[i].intensityVector),\r\n\t\t\t\tarrowLengthPx\r\n\t\t\t)\r\n\r\n\t\t\tlet color = 0\r\n\t\t\t// const middleValueIntensity = (maxValueIntensity + minValueIntensity) / 2\r\n\t\t\t// if (intensity < middleValueIntensity) {\r\n\t\t\t// \tcolor = Math.round(map(intensity, minValueIntensity, middleValueIntensity, 255, 0))\r\n\t\t\t// }\r\n\r\n\t\t\tcolor = Math.round(map(intensity, minValueIntensity, maxValueIntensity, 255, 0))\r\n\r\n\t\t\tctx.strokeStyle = `rgb(${color}, ${color}, ${color})`\r\n\r\n\t\t\tdrawArrow(\r\n\t\t\t\ttransformToScreen(\r\n\t\t\t\t\tnew Point(\r\n\t\t\t\t\t\tintensityVectorArray[i].position.x * convertToScreen,\r\n\t\t\t\t\t\tintensityVectorArray[i].position.y * convertToScreen\r\n\t\t\t\t\t),\r\n\t\t\t\t\tcanvasElement\r\n\t\t\t\t),\r\n\t\t\t\ttransformToScreen(\r\n\t\t\t\t\tnew Point(\r\n\t\t\t\t\t\tintensityVectorArray[i].position.x * convertToScreen + direction.x,\r\n\t\t\t\t\t\tintensityVectorArray[i].position.y * convertToScreen + direction.y\r\n\t\t\t\t\t),\r\n\t\t\t\t\tcanvasElement\r\n\t\t\t\t),\r\n\t\t\t\t{\r\n\t\t\t\t\theadArrowWidth: 10,\r\n\t\t\t\t\theadArrowHeight: 10,\r\n\t\t\t\t\tdraw: (arrowVertexes) => drawArrowOnCanvasContext2D(arrowVertexes, ctx)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n}","import {createArrowVertexes} from './createArrowVertexes'\r\nimport {createAxisXArrowVertexes} from './createAxisXArrowVertexes'\r\n\r\n/**\r\n * Высота головы стрелки по умолчанию.\r\n */\r\nconst headArrowDefaultHeight = 10\r\n\r\n/**\r\n * Ширина головы стрелки по умолчанию.\r\n */\r\nconst headArrowDefaultWidth = 10\r\n\r\n/**\r\n * @param {Point} point1 Начало стрелки.\r\n * @param {Point} point2 Конец стрелки (конец это где рисуется голова стрелки).\r\n * @param options\r\n * @param {Number} options.headArrowHeight\r\n * @param {Number} options.headArrowWidth\r\n * @param {Function} options.draw\r\n */\r\nexport function drawArrow(point1, point2, options) {\r\n\tconst { draw } = options\r\n\t// Создаем стрелку на оси Х.\r\n\tconst normalizedArrowVertexes = createAxisXArrowVertexes(point1, point2, options)\r\n\t// Создаем стрелку уже на своем месте.\r\n\tconst arrowVertexes = createArrowVertexes(point1, point2, normalizedArrowVertexes)\r\n\t// Рисуем стрелку.\r\n\tdraw(arrowVertexes)\r\n}","import {createRotationMatrix} from '../Math/MatrixOperations/createRotationMatrix'\r\nimport {multiplyMatrixByVectorArray} from '../Math/MatrixOperations/multiplyMatrixByVectorArray'\r\nimport {Vector} from '../Math/Vector'\r\nimport {calculateVectorAngleByAxisX} from '../Math/VectorOperations/calculateVectorAngleByAxisX'\r\nimport {Point} from '../Math/Point'\r\n\r\n/**\r\n * @param {Point} point1\r\n * @param {Point} point2\r\n * @param {Vector[]} normalizedArrowVertexes\r\n * */\r\nexport function createArrowVertexes(point1, point2, normalizedArrowVertexes){\r\n\tlet resultArrowVertexes = []\r\n\r\n\t// Вращаем стрелку\r\n\tconst arrowAngle = calculateVectorAngleByAxisX(new Vector(point2.x - point1.x, point2.y - point1.y))\r\n\tconst rotationMatrix = createRotationMatrix(arrowAngle)\r\n\r\n\tresultArrowVertexes = multiplyMatrixByVectorArray(rotationMatrix, normalizedArrowVertexes)\r\n\r\n\t// Перемещаем стрелку\r\n\r\n\r\n\tconst arrowPosition = new Vector(point1.x, point1.y)\r\n\r\n\tlet resultArrowVertexes2 = []\r\n\tfor (const normalizedVertex of resultArrowVertexes) {\r\n\t\tresultArrowVertexes2.push(\r\n\t\t\tnew Vector(\r\n\t\t\t\tnormalizedVertex.x + arrowPosition.x,\r\n\t\t\t\tnormalizedVertex.y + arrowPosition.y\r\n\t\t\t)\r\n\t\t)\r\n\t}\r\n\r\n\r\n\treturn resultArrowVertexes2\r\n}","export function createRotationMatrix(angle){\r\n\tconst cos = Math.cos(angle)\r\n\tconst sin = Math.sin(angle)\r\n\treturn [\r\n\t\t[cos, -sin],\r\n\t\t[sin, cos]\r\n\t]\r\n}","import {multiplyMatrixByVector} from './multiplyMatrixByVector'\r\n\r\nexport function multiplyMatrixByVectorArray(matrix, vectorArray) {\r\n\tconst result = []\r\n\tfor (const vector of vectorArray) {\r\n\t\tresult.push(multiplyMatrixByVector(matrix, vector))\r\n\t}\r\n\treturn result\r\n}","import {Vector} from '../Vector'\r\n\r\nexport function multiplyMatrixByVector(matrix, vector){\r\n\treturn new Vector(\r\n\t\tmatrix[0][0] * vector.x + matrix[0][1] * vector.y,\r\n\t\tmatrix[1][0] * vector.x + matrix[1][1] * vector.y\r\n\t)\r\n}","/**\r\n * Угол между вектором и осью Х.\r\n * Угол отсчитывается от оси Х против часовой стрелки до вектора.\r\n * Может быть отрицательным, то есть может принимать значения от -Math.PI до Math.PI.\r\n * @param {Vector} vector\r\n * @returns\r\n */\r\nexport function calculateVectorAngleByAxisX(vector) {\r\n\treturn Math.atan2(vector.y, vector.x)\r\n}","import {Vector} from '../Math/Vector'\r\nimport {Point} from '../Math/Point'\r\nimport {calculateDistanceBetweenPoints} from '../Math/PointOperations/calculateDistanceBetweenPoints'\r\n\r\n/**\r\n * Высота головы стрелки по умолчанию.\r\n */\r\nconst headArrowDefaultHeight = 10\r\n\r\n/**\r\n * Ширина головы стрелки по умолчанию.\r\n */\r\nconst headArrowDefaultWidth = 10\r\n\r\n/**\r\n * @param {Point} point1 Начало стрелки.\r\n * @param {Point} point2 Конец стрелки (конец это где рисуется голова стрелки).\r\n * @param options\r\n * @param {Number} options.headArrowHeight\r\n * @param {Number} options.headArrowWidth\r\n */\r\nexport function createAxisXArrowVertexes(point1, point2, options){\r\n\tconst {\r\n\t\theadArrowWidth: headArrowWidth = headArrowDefaultWidth,\r\n\t\theadArrowHeight: headArrowHeight = headArrowDefaultHeight} = options\r\n\tconst arrowLength = calculateDistanceBetweenPoints(point1, point2)\r\n\tconst result = [new Vector(0, 0)]\r\n\tresult.push(new Vector(arrowLength, 0))\r\n\tresult.push(new Vector(arrowLength - headArrowHeight, headArrowWidth / 2))\r\n\tresult.push(new Vector(arrowLength - headArrowHeight, -headArrowWidth / 2))\r\n\treturn result\r\n}","export function drawArrowOnCanvasContext2D(arrowVertexes, ctx){\r\n\tctx.moveTo(arrowVertexes[0].x, arrowVertexes[0].y)\r\n\tctx.lineTo(arrowVertexes[1].x, arrowVertexes[1].y)\r\n\tctx.lineTo(arrowVertexes[2].x, arrowVertexes[2].y)\r\n\tctx.moveTo(arrowVertexes[1].x, arrowVertexes[1].y)\r\n\tctx.lineTo(arrowVertexes[3].x, arrowVertexes[3].y)\r\n\tctx.stroke()\r\n}","import {transformToScreen} from '../../Library/Draw/transformToScreen'\r\nimport {Point} from '../../Library/Math/Point'\r\n\r\nexport function drawGridPoint(x, y, scale, canvasElement) {\r\n\r\n\tlet ctx = canvasElement.getContext('2d')\r\n\tconst point = transformToScreen(new Point(x * scale, y * scale), canvasElement)\r\n\tctx.fillRect(\r\n\t\tpoint.x,\r\n\t\tpoint.y,\r\n\t\t1,1)\r\n\r\n\tctx.fillRect(\r\n\t\tpoint.x + 1,\r\n\t\tpoint.y,\r\n\t\t1,1)\r\n\tctx.fillRect(\r\n\t\tpoint.x - 1,\r\n\t\tpoint.y,\r\n\t\t1,1)\r\n\tctx.fillRect(\r\n\t\tpoint.x,\r\n\t\tpoint.y + 1,\r\n\t\t1,1)\r\n\tctx.fillRect(\r\n\t\tpoint.x,\r\n\t\tpoint.y - 1,\r\n\t\t1,1)\r\n}","\r\nexport function map(x, in_min, in_max, out_min, out_max)  {\r\n\treturn (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\r\n}"],"names":["$bfe3c5b1f99c60ca$export$9b781de7bf37bf48","constructor","x","y","_x","_y","$0e38986d1e12c35a$export$baf26146a414f24a","$5f7171fd448aba12$export$926841721d7d6cbd","point1","point2","Math","sqrt","$ff8e3298100e11ba$export$1688a8338e895043","vector","$8e81cc6caae514b7$export$3748d6ca43eb5eeb","number","$9c190cd7d83c0db4$export$4d973b3eababff1d","vectorLength","$c5d5d6167b05d2e0$export$8fa91d40d0bb1393","vector1","vector2","$39f43304e3347fea$export$2752529268d59cb9","distance","electricCharge","$13e4ba37a9f785f5$export$1c1772b000b7cc30","point","canvas","height","$00919d6f63f91579$var$electricChargeArray","value","positionInMeters","$00919d6f63f91579$var$intensityVectorArray","electricChargeArray","example","document","querySelector","HTMLCanvasElement","Error","ctx","getContext","width","window","innerWidth","innerHeight","ratio","cameraWidth","testPoints","reduce","result","charge","dist","push","intensityVectorArray","intensityVector","i","length","electricChargePosition","testPointPosition","normalisedIntensityVector","position","$00919d6f63f91579$var$canvasElement","$00919d6f63f91579$var$ctx","canvasElement","convertToScreen","beginPath","fillStyle","scale","fillRect","minValueIntensity","maxValueIntensity","intensity","direction","color","round","out_max","in_max","strokeStyle","options","draw","normalizedArrowVertexes","headArrowWidth","headArrowHeight","arrowLength","arrowVertexes","resultArrowVertexes","arrowAngle","atan2","rotationMatrix","angle","cos","sin","matrix","vectorArray","arrowPosition","resultArrowVertexes2","normalizedVertex","moveTo","lineTo","stroke","radius","arc","PI","fill","$00919d6f63f91579$var$scaleTextElement","getElementById","innerText"],"version":3,"file":"index.7d19671e.js.map"}